`created at 2023.06.23`

## 🧡 useEffect 란 ?

```jsx
useEffect(setup, dependencies?)
```

**`useEffect`**란 리액트 컴포넌트에서 사용할 수 있는 **`Hook`**으로**,** 컴포넌트를 외부의 시스템과 동기화 시켜주는 함수이다. 쉽게 말해, **컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있도록 하는 `Hook`**이다. 외부에서 **`dependencies`**로 전달된 어떠한 값이 변화되었을 때, **`setup`** 다시 렌더링되어 상태를 동기화 해준다.

## 🧡 파라미터

### setup 함수

렌**더링 이후 실행할 함수. `setup`** 사이드 효과를 가진 함수로 선택적으로 **`clean-up`**기능을 하는 함수(useEffect의 setup 안에서 return 되는 함수) 을 리턴하기도 한다. DOM에 컴포넌트가 추가될 때, 리액트는 **`setup`**함수를 실행한다.  **`dependencies`**가 비어있는 경우에는 컴포넌트가 사라질 때 **`cleanup`** 함수가 호출됩니다

디펜던시가 바뀔때마다 리렌더링되며, 리액트는 **`clean-up`** 함수가 존재할 경우 먼저 이전값으로 함수를 실행하고 새로운 값들로 **`setup`**함수를 실행한다.

### dependecies (optional) 배열

**배열의 형태**로 **`setup` 코드 내부에서 반응하는 모든 reactive한 값들의 리스트**이다. **이 `dependencies`한 값이 변경 되면, `setup`을 재실행한다.**

이 때 반응적인 값들은 **`props`**, **`state`**, 컴포넌트 내부에 선언되어있는 모든 함수와 값들이며,

리액트용 린터는 모든 반응값들이 **`dependency`** 목록에 맞게 구성되어 있는지 확인한다.

**`dependency`** 목록은 상수 개수여야 하고, **`[dep1, dep2, dep3]`** 같이 인라인으로 작성된다.

리액트는 각 종속성을 이전 값과 [Object.is](http://object.is/) 비교를 사용하여 비교합니다.

이 인수를 생략하면 **`Effect`**는 컴포넌트의 렌더링마다 실행된다.

### returns

**`return`** 값은 **`undefined`** 이다.

## 🧡 주의사항

- **`useEffect`**는 **`Hook`**이기 때문에 오직 커스텀 훅이나, 나의 컴포넌트 최상위 수준에서 부를수 있다. 반복문이나, 조건문안에서 호출할수 없다. 만약 필요로 하다면, 새로운 컴포넌트를 만들고, 상태를 해당 컴포넌트로 옮겨줘야 한다.
- 만약 외부 시스템과 동기적으로 동작하지 않는다면, effect효과가 필요 없을수 있다.
- 스트릭모드가 켜져 있을 때, 리액트는 첫번째 실제 setup 전에, 한 번의 추가 개발용 setup + cleanup cycle을 실행 한다. 이것은 나의 cleanup 로직이 setup 로직을 반영하고있는지, setup-logic이 수행하는 모든 작업을 중지시키거나, 되돌릴 수 있는지 확인하는 부하 테스트이다. 이로 인해 문제가 발생하면 cleanup 함수를 구현해주면 된다.
- 만약 몇몇의 dependency들이 컴포넌트 내부에서 정의된 객체들이거나 함수라면, 필요 이상의 사이드 효과가 발생될 수 있다. 이것을 해결하기 위해서는, 불필요한 객체나 함수 dependency 를 제거해야 한다. 상태 업데이트나 non-reactive 사이드 효과를 외부에서 추출할 수 있다.
