`created at 25.03.24`

### 1. 재조정 이해하기

- 우리가 작성한 JSX(컴포넌트)는 `React.createElement`로 변환되어 리액트 엘리먼트 트리를 생성(변환)함
- 변환된 엘리먼트 트리는 흔히 말하는 `가상돔`이 된다.(완전히 동일한 것은 아니나 비슷한 개념)
- 만들어진 가상돔에서 상태나 `props`가 변경되었을 때 `React`는 최소한의 API 호출을 통해 실제 DOM에 변경사항을 반영한다.
- 이 과정을 재조정이라고 한다.
- 리액트 엘리먼트 트리(복습을 위해 가져온 것..)
  ```jsx
  // type은 문자열이거나 함수
  // type이 함수라면 props 를 전달하여 해당 함수를 호출함
  // type이 문자열이라면 해당 문자열을 태그 이름으로 하는 HTML 엘리먼트를 생성하고, 해당 엘리먼트 내에 자식 노드를 렌더링
  // 리액트는 엘리먼트의 깊숙한 단계로 들어가다가 children이 스칼라인 값을 만나면 이를 텍스트 노트로 렌더링 함
  {
    type : 'main',
    props : {
      children : {
        type : 'div',
        props : {
          children : [
            {
              type : 'h1',
              props : {
                children : '안녕하세요!',
              }
            },
            {
              type : 'span',
              props : {
                children :['카운트 : ', count],
              }
            },
            {
              type : 'button',
              props : {
                onClick : () => setCount(count + 1),
                children : '증가'
              }
            }
          ]
        }
      }
    }
  }
  ```

### 2. 일괄 처리

- 리액트는 가상 DOM 트리를 복제해 새로운 가상 DOM트리를 생성하고, 여러번의 변경을 일괄 처리한다.
- 아래와 같은 코드에서 `count`는 1씩 세번 증가하는 것이 아니라 3이 증가한다
  ```jsx
  const Example = () => {
    const [count, setCount] = useState();

    const handleClick = () => {
      setCount((prev) => prev + 1);
      setCount((prev) => prev + 1);
      setCount((prev) => prev + 1);
    };

    return (
      <>
        <p>카운트 : {count}</p>
        <button onClick={handleClick}>증가</button>
      </>
    );
  };
  ```

### 3. 기존 기술

- 스택 재조정자
  - 예전 리액트 재조정자는 스택 기반 알고리즘을 사용해 이전 가상트리와 새 가상트리를 비교함
  - 문제점
    - 스택에 들어간 순차적으로 렌더링을 하기 때문에, 비용이 많이 드는 컴포넌트를 렌더링하는 동안 다른 컴포넌트에 지연을 줌
    - 사용자 입력처럼 상호작용이 빨라야 하는 작업은 먼저 수행되어야 하는데 스택 재조정자는 우선순위가 없음
    - 현재 처리중인 업데이트(스택에서 작업중인 업데이트)는 중단할 수 없음
  - 리액트는 이 문제를 해결하기위해 파이버 아키텍처를 채택함
- **파이버**
  - 작업 단위를 표현하는 데이터 구조
  - 리액트 엘리먼트로부터 생성됨
  - 특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트 내부 데이터 구조
  - 아래와 같은 컴포넌트 정보가 들어있다.
    ```jsx
    {
    	tag : 3,
    	type : App,
    	key : null,
    	ref : null,
    	props : {
    		name : 'kyoung',
    		age : '20'
    	},
    	stateMode : AppInstance,
    	return : FiverParent,
    	child : FiberChild,
    	sibling : FiberSibling,
    	index : 0,
    	...
    }
    ```
    - tag : 컴포넌트 유형을 나타내는 고유한 숫자 ID (ex. 클래스 컴포넌트, 함수 컴포넌트, 서스펜스 및 오류경계 등)
    - type : 파이버가 나타내는 컴포넌트
    - props : 컴포넌트에 대한 입력 props, 함수에 대한 입력인수
    - stateMode : 파이버가 나타내는 컴포넌트의 인스턴스
- 파이버 재조정자
  - 파이버 재조정자는 업데이트의 우선순위를 정하고, 동시실행을 가능캐 해 리액트 어플리케이션 성능과 응답성을 향상시켰다.
  - 파이버 재조정은 현재 파이버 트리와 다음 파이버 트리에서 변경사항을 찾는 작업이다.
    - `createFiberFromTypeAndProps` 함수는 각 리액트 엘리먼트를 통해 파이버 노드를 생성
  - 업데이트가 발생하면 현재 파이버 트리가 포크 되어새로운 상태를 반영하도록 업데이트 된다. 이를 **렌더링**이라고 함
  - 상태 반영이 마무리 된 파이버 트리를 이전 파이버 트리와 교체하는데 이를 **커밋**이라고 함
- 파이버 재조정
  - 파이버 재조정은 렌더링단계와 커밋단계로 이루어짐 → 중간 멈출 수 있음 → 리액트 스케줄러가 실행을 메인 스레드로 돌려주기 때문에
- 렌더링 단계
  - 렌더링 단계는 상태 변경 이벤트가 발생하면 시작되며 `beginWork`함수와 `completeWork`함수가 수행되다.
  - 시그니처
    ```jsx
    function (beginWork | completeWork) {
    	current : Fiber | null,
    	workInProgress : Fiber,
    	renderLanes : Lanes
    } : Fiber | null;
    ```
    - beginWork와 completeWork의 시그니처는 같음
    - current : 이전 파이버 트리에 파이버 노드에 대한 참조
    - workInProgress : 새로운 파이버 트리에서 업데이트 중인 파이버노드에 대한 참조
    - renderLanes : 업데이트 순서를 처리하는 레인을 나타내는 비트마스크
  - beginWork(작업 시작)
    - 파이버 노드에 업데이트 필요 여부를 나타내는 플래그를 설정하는 함수
  - completeWork(작업 완료)
    - 작업용 파이버 노드에 업데이트를 적용하고, 이를 기반으로 실제 DOM 트리를 구축함
    - 이 과정에서 우선순위가 더 높은 업데이트가 예약되면 만들어진 UI는 버려질 수 있다.
- 커밋 단계
  - 변형단계와 레이아웃 단계로 구성되어 있고 여러 Effect들이 특정 순서로 실행된다.
  - 변형단계
    - `commitMutationEffects`함수를 호출해 렌더링 단계에서 가상 DOM에 적용된 변경사항을 실제 DOM에 반영(사용되지 않는 노드를 제거하기도 함)
  - 레이아웃 단계
    - `commitLayoutEffects`함수를 호출해 DOM에서 업데이트 된 노드의 새 레이아웃을 계산함
  - Effect
    - 배치 : 새 컴포넌트가 DOM에 추가될 때 발생
    - 업데이트 : 컴포넌트가 새로운 프롭이나 상태로 업데이트 될 때 발생
    - 삭제 : 컴포넌트가 DOM에서 제거될 때 발생
    - 레이아웃 : 브라우저의 페인트 가능 시점 전에 발생
  - 패시브 Effect
    - 브라우저 페인트 가능 시점 후에 실행되도록 예약된 사용자 정의 효과
    - `useEffect`를 통해 만들어 짐

### 🎊 복습하기

1. **리액트 재조정이란 무엇인가요 ?**
   - 이전의 돔 트리와 현재 돔 트리의 변경사항을 찾고, 이 변경사항을 일괄처리하여 실제 DOM에 반영하는 과정
2. **파이버 데이터 구조의 역할은 무엇인가요 ?**
   - 파이버 구조를 사용하면 각 작업에 우선순위를 설정할 수 있다. 또한, 업데이트 과정을 더 세분화 하여 우선순위가 높은 작업이 추가된다면 작업중인 업데이트를 중단할 수 있다.
3. 왜 트리가 두 개 필요한가요 ?
   - 하나의 트리는 화면에 보여주는 역할을 하고, 다른 트리에서 변경사항을 처리한다.
4. 애플리케이션이 업데이트되면 어떻게 되나요 ?
   - 변경사항이 다 적용되면, 이 트리를 화면에 보여주는 트리로 변경한 뒤 다른 트리에서 다시 변경사항을 적용함
