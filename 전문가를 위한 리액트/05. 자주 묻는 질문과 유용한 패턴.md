`created at 25.03.10`

### 1. React.memo를 사용한 메모화

- **메모화**
  - 컴퓨터 과학 기법에서 이전에 계산된 결과를 캐싱해 함수의 성능을 최적화 하는 기법
  - 함수의 순수성을 필요로 함
  - 리액트에서는 React.memo를 사용해 메모화를 적용할 수 있다.
- React.memo 정의
  ```jsx
  	const MemoizedComponent = React.memo(SomeComponent, arePropsEqual?)

  ```
  - 메모이제이션 하고자 하는 컴포넌트를 **`memo`**로 감싸서 memoized된 **새로운 컴포넌트**를 반환해 불필요한 리렌더링을 막는 HOC 함수이다.
  - 두번째 매개변수로 의존성 배열을 전달받는다.
- React.memo 동작 원리
  - React.memo는 메모화 된 컴포넌트를 업데이트 해야하는지, 아님 건너뛸지를 판단하는 역할을 하는 함수
  - 최초 렌더링과 업데이트 과정을 모두 처리하고 있으며, 새 파이버를 생성해야 하는지 기존 파이버를 업데이트 해야하는지를 판단한다.
  - 그렇기 때문에 무분별한 사용은 오히려 성능을 악화시킴
  - 리액트는 React.memo로 감싸진 컴포넌트의 props에 **얕은 비교를** 수행해 프롭의 변경 여부를 확인함
  - 이 때 스칼라타입은 얕은 비교로 비교가 가능하지만 함수, 배열, 객체는 메모리 주소로 비교하기 때문에 얕은 비교로 비교가 어려움
  - 따라서 자식 컴포넌트에 배열, 객체, 함수 형태로 프롭을 전달하면 부모컴포넌트가 렌더링될때마다 변화하는 참조값으로 인해 자식 컴포넌트도 강제 렌더링됨
  - 이를 막기 위해서
    - 프롭이 배열이나 객체라면 ? → useMemo 사용
    - 프롭이 함수 형태라면 ? → useCallback 사용
  - React.memo의 문제점
  - 모든 변수 선언을 useMemo로 감싸야 하느냐 ? → No.
    - useMemo 함수를 읽고 실행하는 작업이 최적화하려는 실제 작업보다 비용이 많이든다.
    - 유용한 경우 : 계산 비용이 많이 드는 연산을 메모화 하거나 객체와 배열에 대한 안정적인 참조가 필요할 때
  - 모든 함수 선언을 useCallback으로 감싸야 하느냐 ? → No.
    - 내장 컴포넌트/호스트 컴포넌트에 전달되는 프롭은 컴포넌트에 직접 추가하는 것이 아니라 최상위 수준에서 위임됨 → 대부분 크게 도움되지 않고 부하만 추가됨
    - 유용한 경우 : 자주 리렌더링할 가능성이 있는 컴포넌트에서 비용이 많이 드는 하위 컴포넌트로 콜백을 전달할 때
- 메모화를 해야할 지, 아닌지에 대한 판단이 어려움
- 최근 리액트에서 제공하는 리액트 컴파일러(리액트 포겟)가 메모이제이션을 자동화할 예정
- 그림편집기나 도형이동등의 작업을 렌더링 할 경우에 유용
