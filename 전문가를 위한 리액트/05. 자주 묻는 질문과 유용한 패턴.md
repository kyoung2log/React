`created at 25.03.10`

### 1. React.memo를 사용한 메모화

- **메모화**
  - 컴퓨터 과학 기법에서 이전에 계산된 결과를 캐싱해 함수의 성능을 최적화 하는 기법
  - 함수의 순수성을 필요로 함
  - 리액트에서는 React.memo를 사용해 메모화를 적용할 수 있다.
- React.memo 정의

  ```jsx
  	const MemoizedComponent = React.memo(SomeComponent, arePropsEqual?)

  ```

  - 메모이제이션 하고자 하는 컴포넌트를 **`memo`**로 감싸서 memoized된 **새로운 컴포넌트**를 반환해 불필요한 리렌더링을 막는 HOC 함수이다.
  - 두번째 매개변수로 의존성 배열을 전달받는다.

- React.memo 동작 원리
  - React.memo는 메모화 된 컴포넌트를 업데이트 해야하는지, 아님 건너뛸지를 판단하는 역할을 하는 함수
  - 최초 렌더링과 업데이트 과정을 모두 처리하고 있으며, 새 파이버를 생성해야 하는지 기존 파이버를 업데이트 해야하는지를 판단한다.
  - 그렇기 때문에 무분별한 사용은 오히려 성능을 악화시킴
  - 리액트는 React.memo로 감싸진 컴포넌트의 props에 **얕은 비교를** 수행해 프롭의 변경 여부를 확인함
  - 이 때 스칼라타입은 얕은 비교로 비교가 가능하지만 함수, 배열, 객체는 메모리 주소로 비교하기 때문에 얕은 비교로 비교가 어려움
  - 따라서 자식 컴포넌트에 배열, 객체, 함수 형태로 프롭을 전달하면 부모컴포넌트가 렌더링될때마다 변화하는 참조값으로 인해 자식 컴포넌트도 강제 렌더링됨
  - 이를 막기 위해서
    - 프롭이 배열이나 객체라면 ? → useMemo 사용
    - 프롭이 함수 형태라면 ? → useCallback 사용
  - React.memo의 문제점
  - 모든 변수 선언을 useMemo로 감싸야 하느냐 ? → No.
    - useMemo 함수를 읽고 실행하는 작업이 최적화하려는 실제 작업보다 비용이 많이든다.
    - 유용한 경우 : 계산 비용이 많이 드는 연산을 메모화 하거나 객체와 배열에 대한 안정적인 참조가 필요할 때
  - 모든 함수 선언을 useCallback으로 감싸야 하느냐 ? → No.
    - 내장 컴포넌트/호스트 컴포넌트에 전달되는 프롭은 컴포넌트에 직접 추가하는 것이 아니라 최상위 수준에서 위임됨 → 대부분 크게 도움되지 않고 부하만 추가됨
    - 유용한 경우 : 자주 리렌더링할 가능성이 있는 컴포넌트에서 비용이 많이 드는 하위 컴포넌트로 콜백을 전달할 때
- 메모화를 해야할 지, 아닌지에 대한 판단이 어려움
- 최근 리액트에서 제공하는 리액트 컴파일러(리액트 포겟)가 메모이제이션을 자동화할 예정
- 그림편집기나 도형이동등의 작업을 렌더링 할 경우에 유용

### 2. 지연로딩

- **code spliting**

  ```jsx
  import.("./large.js").then((module) => {
    // ...
  });
  ```

  - 개념 : 코드를 여러 개의 작은 번들로 나누어서 필요한 자바스크립트만 읽어들이는 기법
  - 목적 : 자바스크립트 번들의 크기가 커 페이지 로딩이 지연되는 경우, 초기 로딩 속도를 빠르게 하고, 불필요한 코드 다운로드를 방지
  - 언제 사용?
    - 특정 페이지(라우트)에서만 필요한 컴포넌트를 분리
    - 자주 사용되지 않는 모듈(예: 관리자 페이지) 분리

- **지연로딩**

  - 개념 : 필요할 때까지 특정 리소스(컴포넌트, 이미지, 데이터 등)를 로드하지 않는 기법
  - 목적 : 불필요한 자원 로드를 지연시켜 성능을 최적화
  - 언제 사용?
    - **이미지, 비디오, 외부 API 데이터** 로딩을 최적화할 때
    - 사용자가 **스크롤할 때만 필요한 리소스를 불러올 때**

- **React.lazy와 Suspense를 사용한 지연로딩**

  - 리액트에서는 react.lazy(code spliting 기법)과 Suspense를 사용해 성능최적화(지연로딩)를 할 수있다.
  - Suspense는 트리 내의 모든 컴포넌트를 숨기므로, 필요한 컴포넌트를 감싸는 용도로만 사용한다.

### 3. useState와 useReducer

- useReducer를 사용할 때 얻는 이점 3가지
  - 상태 업데이트 로직을 분리해 단일 책임 원칙을 따르기 좋고 테스트가 용이하다.
  - 상태 변경은 useReducer와 함께 명시적으로 이루어져 상태 업데이트흐름을 파악하기 쉽다.
  - useReducer는 이벤트 소스 모델이기 때문에 로드 디버깅에 용이하다.

### 4. 리액트 디자인 패턴

- **소프트웨어 디자인 패턴**

  - 다른 개발자가 이미 겪고 해결한 문제를 패턴화 해 재사용성, 유지보수성, 효율성을 높여준다.

- **프레젠테이션/컨테이너 컴포넌트**

  - 프레젠테이션 : UI를 렌더링
  - 컨테이너 : UI의 상태를 처리함

- **고차 컴포넌트**

  - 동일한 로직이 여러 컴포넌트에서 중복되는 경우 이를 분리해 재사용할 수 있게 만드는 디자인 패턴
  - 예시) 모든 컴포넌트의 관심사인 `loading`, `error` 상태에 따라 다른 UI를 렌더링 하는 컴포넌트를 만들어 감싸준다.

- **고차 컴포넌트 합성**

  - 중첩된 고차 컴포넌트의 문제를 해결하기 위한 함수를 만들어 중첩을 flat 시키는 기법
  - reduceRight 을 사용해 오르녹에서 왼쪽으로 고차 컴포넌트를 합성한다.

- **프롭 컬렉션 + 프롭 게터**

  - 프롭 컬렉션 : 여러개의 프롭을 묶어서 전달하는 기법
  - 프롭게터 : 프롭 컬렉션에 한가지 기능을 추가할 때 이전의 기능을 덮어씌우는 대신 병합할 수 있도록 해주는 기법

- **복합 컴포넌트**

  - 같은 상태를 공유하며 독립적으로 렌더링 되는 컴포넌트를 묶어서 구현할 수 있도록 하는 디자인패턴
  - 루트에 콘텍스트를 사용해 자식들을 감싸준 뒤, 자식들은 useContext를 사용해 루트의 상태에 접근

- **상태 리듀서**

  - 상태 리듀서 프롭을 전달받아 내부 리듀서 전달받은 외부 리듀서 로직을 결합시켜 컴포넌트 동작을 수정할 수 있게하는 디자인 패턴

### 🎊 복습하기

1. **리액트에서 메모화란 무엇이며, 컴포넌트 렌더링을 최적화하는 데 어떻게 사용할 수 있을까요 ?**
   - 메모화 : 이전에 그려진 컴포넌트를 캐싱해 렌더링을 최적화하는 방법
   - 이전에 그려진 컴포넌트가 순수함수이고, props가 바뀌지 않아 리렌더링을 할 필요가 없을 때 React.memo를 사용해 컴포넌트를 캐싱할 수 있다.
2. **리액트에서 상태 관리를 위해 useReducer를 사용하면 어떤 우세한 점이 있으며, useReducer는 useState와 어떻게 다른가요?**
   - useState는 useReducer를 추상화 한 함수로 단일 값을 관리하는데 용이하고 useReducer는 복잡한 객체 상태를 관리하는데 용이하다.
   - useReducer 를 사용할 경우 우세한 점
     1. 상태 업데이트 로직을 분리해 단일책임원칙을 지킬 수 있으며, 테스트 코드 작성하기 쉽다.
     2. useReducer 액션 함수를 통해 상태 변화의 흐름을 명시적으로 확인할 수 있다.
     3. useReducer는 이벤트 소스 모델을 사용하기 때문에 이벤트의 진단 로그를 딸 수 있다. << 그냥 개발자에겐 도움되진 않지만, 라이브러리 개발자에겐 유용할 듯
3. **`React.lazy`와 `Suspense`컴포넌트를 사용하는 리액트 애플리케이션에서 지연 로딩을 어떻게 구현할 수 있나요?**
   - React.lazy로 느리게 가져올 컴포넌트르 명시적으로 지정하고, Suspense로 감싸 컴포넌트가 로드중일 때 보여줄 수 있는 fallbackUI를 렌더링한다.
4. **리액트에서 메모화를 사용할 때 발생할 수 있는 잠재적 문제는 무엇이며 어떻게 완화할 수 있을까요?**
   - 메모화 된 컴포넌트의 props으로 전달된 상태 내부 값이 달라지지 않았음에도 불구하고, 함수나 객체의 참조값이 바뀌어 불필요하게 컴포넌트를 렌더링하는 문제가 있다.
   - 해결방법 : props이 배열이나 객체라면 useMemo, 함수라면 useCallback으로 메모화 해 참조값을 기억한다.
5. **리엑트에서 컴포넌트에 프롭으로 전달된 함수를 메모화하기 위해 useCallback 훅을 어떻게 사용할 수 있나요?**
   - 함수를 정의할때 useCallback으로 한번 감싸준다.
